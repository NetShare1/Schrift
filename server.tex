\chapter{Multi-Wan Bonding Proxy Server}
\label{cha:Server}

\section{Anforderungen des Multi-Wan Bonding fähigen Proxy Servers}
Unser Multi-Wan Bonding Proxy Server ist dafür verantwortlich Datenpakete des Windows Treibers zu Empfangen und zusammen zu führen und Antwortpakete aus dem Internet aufzuteilen um die an den Windows Treiber zurück zu senden. Dafür müssen Probleme gelöst werden:
\\
\begin{enumerate}
    \item Sammeln von IP Paketen von mehreren Absendeadressen für das selbe Ziel.
    \item Aufteilen von IP Paketen aus dem Internet auf mehrere Verbindungen des selben Empfängers.
    \item NAT Anwenden auf eingehende und Ausgehende IP Pakete.
\end{enumerate}
\ \\
Weiters handelt es sich bei unserem Multi-Wan Bonding Proxy Server um einen Endpunkt für die zu bündelnten Internetverbindungen. Aufgeteilte Datenpakete treffen von verschiedenen Verbindungen beim Server ein und werden wieder zu einem einzelnen Datenstrom zusammengeführt. Antworten an unseren Proxy Server werden ebenfalls entsprechend wieder aufgeteilt und an die verschiedenen WAN-Anbindungen des Nutzers gesendet. 
\\\\
Außerdem müssen gewisse Standards von Performance, Stabilität und Ressourcenanforderungen eingehalten werden. Hierbei gilt:
\\
\begin{enumerate}
    \item Maximale prozentuale CPU Auslastung von 5 {\%}, bei einer 100 Mbit/s Übertragungsrate auf einem AMD Ryzen 7 3700X
    \item Nicht mehr als 300 Megabyte RAM bedarf höchstens.
\end{enumerate}

\section{Server Infrastruktur}
\subsection{Betriebssystem}
Wir haben uns bei der Wahl des Server Betriebsystems für Linux entschieden. Um genau zu sein für Debian 8. 
Dafür gibt es einige Gründe:
\\
\begin{enumerate}
    \item Der Linux Kernel besitzt bereits Standardmäßig einen TUN/TAP Treiber was die Entwicklung des Servers um einiges vereinfacht. Bei Windows müsste man erst einen eigenen Treiber schreiben bzw. eine externe Bibliothek verwenden um einen virtuellen Netzwerkadapter zu erstellen. Dies ist unter Linux nicht notwendig.
    \item Mittels iptables ist es nur ein minimaler Aufwand NAT auf einen Netzwerkadapter anzuwenden. 
    \item Debian ist im vergleich zu Windows um einiges "leichter" damit sinken die Leistungsanforderungen an das Hostsystem erheblich. Debian benötigt Beispielsweiße keinen Desktop. Der Proxy Server selbst ist auch sehr Leistungsschonend weshalb hier schon ein älterer Raspberry PI ausreichen würde.
\end{enumerate}
\ \\
Es gibt aber viele Linux distributionen die diese Funktionalitäten haben. Warum haben wir uns also speziell für Debian 8 entschieden? Die beliebtesten Serverbetriebsysteme sind aktuell Debian, Ubuntu, CentOS und Windows ohne spezielle Reinfolge. Die entscheidung viel auf Debian weil es sich nicht nur um eine der am weitesten verbreiteten Distributionen handelt sondern auch weil es viele andere Distributionen gibt die auf Debian aufbauen. Ubuntu ist eine davon. Dies erlaubt es unserem Server auf einer vielzahl an Servern ohne hohem Aufwand zu laufen. Wir sind uns aber ziemlich sicher das es auch unter anderen Linux Distributionen keine großen Probleme geben sollte sofern man den Source-Code extra für diese kompiliert.

\subsection{Hardware}
Die Anforderungen an die Hardware sind minimal. Selbst ein schwaches Hostsystem kann unseren  Proxy Server ohne Probleme betreiben. 1GB Arbeitsspeicher ist mehr als genügend und mit 2GHz CPU Takt sollten bereits höhere Datenübertragungsraten ohne Probleme möglich sein. 
\\\\ 
Die höchste Relevanz für die Leistung unseres Proxy Servers hat die single Core Leistung des Rechners. Besonders wenn Datenraten von über 100Mbit/s das Ziel sind sollte man darauf achten.
\\\\
Die Internetanbindung ist auch von besonders hoher Relevanz. Die Summer aller mit dem Server verbundenen Nutzer kann zusammen nie eine höhere Übertragungsrate als der Hastrechner haben. 
\\\\
Festplattenspeicher wird praktisch keiner benötigt. Schon ein paar MB sind ausreichend um den Server in Betrieb zu nehmen. Vorrausgesetzt es werden keine Logfiles gespeichert.


\section{Kommunikation zwischen Server und Client}
\subsection{Der Weg eines Datenpakets von Client zu Server}
Möchte eine Anwendung etwas aus dem Internet abrufen so sendet diese Datenpakete aus. Diese Datenpakete enthalten jeweils eine Absender IP-Adresse, eine Ziel IP-Adresse, Nutzdaten und weitere Metainformationen. Diese Datenpakete müssen nun ihren weg von der Anwendung bis zum Ziel Server bestreiten. 
\\\\
Dabei werden sie, nachdem sie von der Anwendung an der Betriebsystem übergeben wurden, geroutet. Beim Routing wird für ein Datenpaket anhand der Ziel IP-Adresse ein passender Netzwerkadapter gesucht an, den das Datenpaket übergeben wird. Gibt es keine spezielle Route für diese IP-Adresse wird die sogenante Standard-Route genommen. Die Standard-Route fürt im Normalfall zu einem Router dieser Router betreibt Heutzutage erheblich mehr als nur simples Routing ins Internet. 
\\\\
Praktisch immer ist auf diesen Haushalts-Routern eine NAT Funktion aktiviert. Sollte unser Datenpaket nicht für das lokale Netzwerk bestimmt und damit wieder die Standard-Route angewandt werden muss es hier nun eine NAT Wall durchqueren. Dabei ändert sich die Absender IP-Adresse zur öffentlichen IP-Adresse des Routers bevor das Datenpaket ins Internet weitergeleitet wird. Die Ziel IP-Adresse wird später auf die öffentliche IP-Adresse des Routers Antworten.
\\\\
Um nun mehrere verschiedene Internetverbindungen zu bündeln müssen wir Datenpakete für das selbe Ziel über verschiedene Netzwerkadapter hinaussenden. Dies wird in unserem Fall von unserem Windows Treiber erledigt. Dieser leitet Datenpakete für die Standard-Route zu sich und teilt diese dann auf die physische Netzwerkadapter auf. Aufteilen alleine ist hier aber nicht genug da dann beim Zielrechner zusammengehörende Datenpakete von verschiedenen IP-Adressen ankommen würden. 
\\\\
Normale Server sind für diese Art der Kommunikation nicht ausgelegt. Besonders sehr Session behaftete Dienste sollten hier größe Probleme haben wie FTP. FTP schickt nicht mit jedem Datenpaket mit zu welchem aktuell Verbundenem FTP-Nutzer dieses Datenpaket gehört. Kommt nun ein Datenpaket von einer anderen IP-Adresse und sogar von einem anderen Port hat ein FTP-Server keine möglichkeit festzustellen zu welchem Nutzer diese Daten gehört haben. 
\\\\
Um dieses Problem zu behandeln haben wir einen Multi-Wan Bonding Proxy Server entwickeln müssen. Anstelle die Datenpakete einfach nur auf die Netzwerkadapter aufzuteilen verpackt unser Windows Treiber sie zuvor in eigenen Datenpaketen welche an unseren Proxy Server adressiert sind. Unser Server ist darauf ausgelegt von mehreren verschiedenen IP-Adressen und Ports Datenpakete zu empfanden. 
\\\\
Woher weiß unser Server welches Datenpaket zu welchem Nutzer gehört? Der Windows Treiber hat einen virtuellen Netzwerkadapter dieser virtuelle Netzwerkadapter hat eine IP-Adresse. Diese IP-Adresse können wir verwenden um verschiedene Nutzer zu unterscheiden. Aktuell haben wir aber noch keine explizite Mehrbenutzerfähigkeit eingebaut. Trotzdem ist es zumindest erforderlich das sich die IP-Adresse des virtuellen Netzwerkadapters des Nutzers im selben Subnetz befindet wir die IP-Adresse des virtuellen Netzwerkadapters des Servers. Da sonst die entpackten Datenpakete des Nutzers nicht vom virtuellen Netzwerkadapter des Servers akzeptiert werden.
\\\\
Der Server nimmt die verpackten Datenpakte, entpackt diese, wendet auf sie NAT an um sie  dann mit seiner eigenen IP-Adresse als Absender an die Ziel-Adresse zu versenden.

\subsection{Der Weg eines Datenpakets von Server zu Client}
Sendet ein Zielrechner aus dem Internet eine Antwort auf eine Anfrage unseres Proxy Servers so wird auf diese bei der Ankunft NAT angewendet. Nachdem durchschreiten der NAT Wall erhält das Datenpaket eine neue Ziel-Adresse nämlich jene die beim senden der Anfrage vom Nutzer noch unsere Absederadresse war.
\\\\
Die Absenderadresse war ursprünglich die IP-Adresse des virtuellen Netzwerkadapters unseres Windows Treibers. Anhand dieser Ziel IP-Adresse könnte der Server nun feststellen an welchen Nutzer er das Paket zurück senden muss bzw. dadurch weiters an welche der verschiedenen Eingehenden verbindungen und an welche nicht. Da Multiusersupport aber in dem Prototypen noch nicht enthalten ist wird eine Antwort aktuell einfach auf alle vorhandenen Verbindungen aufgeteilt. Die Empfänger IP-Adresse muss aber trotzdem wieder korrekt gesetzt werden da sonst der virtuelle Netzwerkadapter des Clients das Datenpaket nicht akzeptieren würde.
\\\\
Nach dem durchqueren der NAT Wall werden die Datenpakete nun einfach wieder verpackt und an die Internetadressen und Ports zurück gesendet von denen ursprünglich die Anfrage stammt.
\\\\
Nun landen die Datenpakete wieder beim Router des Nutzers bei diesem wird beim durchqueren der NAT Wall die öffentliche IP-Adresse des Nutzers wieder gegen die lokale IP-Adresse ersetzt und an das Datenpaket an den Rechner des Nutzers gerouted.
\\\\ 
Beim Rechner des Nutzers werden diese Datenpakete nun wieder vom Windows Treiber entpackt und an den virtuellen Netzwerkadapter übergeben, welcher die Datenpakte wiederum an die ursprüngliche Applikation übergibt.


\section{Architektur des Multi-Wan Bonding fähigen Proxy Servers}
\subsection{Sammeln von IP Paketen von verschiedenen Absendern}
Um IP Pakete die von unserem Windows Treiber kommen entgegennehmen zu können lauscht der Proxy Server Standardmäßig auf Port 5555 nach UDP Datagrams. 
\\\\
Jedes dieser Datagrams enthält wiederum ein IP Paket des Windows Treibers als Nutzdaten. Das IP Paket im inneren des Datagrams wird nun genommen und weiter durch den Server verarbeitet.
\\\\
Die Nutzdaten sind aber nicht die einzig Wichtigen Informationen in dem Datagram. Der Server speichert sich auch den Endpunkt von dem das Datagram gekommen ist. Dies ist Notwendig da wir davon ausgehen müssen das eine NAT Wall zwischen dem Windows Treiber und Server ist. Durch eine NAT Wall ändert sich jedoch der Absende Port und die IP Adresse. Um später also Daten auch zurück schicken zu können ist es Notwendig sich Port und IP-Adresse zu merken. Einen fixen Port können wir beim zurückschicken deswegen auch nicht nehmen.
\\\\ 
Rücksicht auf einen eventuell beschädigten Inhalt des Datagrams müssen wir auch nicht nehmen. Um die Fehlerbehandlung kümmert sich das TCP im inneren der Nutzdaten des Datagrams. Tatsächlich wäre es ein Problem TCP und nicht UDP zur übertragung zu verwenden da wir dann meistens TCP Pakete über eine TCP Verbindung senden würden. Dies würde zu einem sogenannten TCP Meltdown führen.

\subsection{Senden der gesammelten IP Pakete des Windows Treibers}
Die Nutzdaten der gesammelten Datagrams sind selbst wieder IP Pakete. Diese nehmen wir nun und übergeben als byte Arrays an den virtuellen Netzwerkadapter. Da Datenpakete betreten den virtuellen Netzwerkadapter hierbei von der selben Seite wie es bei einem physischen Netzwerkadapter die Bits und Bytes über das Patch Kabel würden.
\\\\  
Danach wird das Datenpaket gerouted. In den meisten Fällen wird es wohl ein Paket für das Internet sein es kann aber auch ein Paket für die IP-Adresse den virtuellen Netzwerkadapters des Servers sein oder für die öffentliche IP-Adresse des Servers. Sollte an dem Server noch ein weiteres Netzwerk hängen so kann das Paket auch für dieses sein. Ist es jedoch für das Internet bestimmt wird die Standard Route gewählt welche zu dem Netzwerkadapter ins Internet führt. 
\\\\
Nachdem das Paket nun gerouted wurde kommt es hier vor dem versenden ins Internet noch zur Anwendung von NAT. Der Grund dafür ist das die IP-Adresse des Servers nun vom Server selbst als auch von den Nutzern des Proxy Servers verwendet wird. Wärend diesem NAT Prozess wird die Absender IP-Adresse gegen die öffentliche IP-Adresse des Servers getauscht. Danach verlässt das Datenpaket unseren Server ins Internet.

\subsection{Entgegennehmen von Antwort Paketen aus dem Internet}
Antworten aus dem Internet werden direkt nach dem eintreffen beim Server wieder durch die NAT Wall gezogen. Dabei wird die Ziel IP-Adresse, welche bis zu diesem Punkt die öffentliche IP-Adresse des Servers war, gegen die lokale IP-Adresse des virtuellen Netzwerkadapters des Windows Treibers eingetauscht.
\\\\ 
Nun wird das Datenpaket gerouted. Da das routing Ziel die IP-Adresse des Windows Treiber seinen virtuellen Netzwerkadapter ist wird das Datenpaket an den virtuellen Netzwerkadapter des Servers übergeben. Dies geschied da sich der virtuelle Netzwerkadapter des Servers und des Windows Treibers im selben subnetz befinden müssen.  
\\\\
Nach der entgegenname durch den virtuellen Netzwerkadapter erhalten wir das IP Paket als byte array welches wir nun wieder an den Windows Treiber senden müssen.

\subsection{Senden von Antwort Paketen an den Windows Treiber}
Jene Datenpakete welche wir als Byte Arrays aus dem virtuellen Netzwerkadapter gezogen haben senden wir über die ganz normale UDP Socket API unter Linux an den Windows Treiber. 
\\\\
Dabei erstellen wird wieder ein Datagram und verwenden als Nutzdaten das IP Paket welches wir als byte array vorliegen haben. Als Zieladresse und Ziel Port verwenden wir einen der Endpunkte welche wir beim Empfangen der Anfragen erhalten haben.
\\\\
Nun durchqueren das Datagram vermutlich noch die NAT Wall des Nutzers bevor es vom Windows Treiber weiter verarbeitet wird. 


\section{Implementierung des Multi-Wan Bonding Proxy Servers}
\subsection{Notwendigkeit eines virtuellen Netzwerkadapters}
Zur implementierung unseres Multi-Wan Bonding Servers ist ein virtueller Netzwerkadapter notwendig. Der Grund dafür ist das es für uns keine andere möglichkeit gibt Datenpakete in ihrer roh Form, in unserem Fall byte arrays, von dem System zu bekommen oder zu übergeben. 
\\\\
Anwendungen verwenden für gewöhnlich entsprechende "System Calls" um die Netzwerk Funktionalitäten des Betriebsystems zu verwenden. Anders würde es auch nicht gut gehen da Anwendungen die direkt mit der Hardware kommunizieren ein Sicherheitsrisiko darstellen würden.
\\\\
Natürlich wäre es für uns auch möglich gewesen eine eigene API ohne virtuellen Netzwerkadapter zu erstellen, dies würde jedoch dazu führen das NetShare nur von jenen Applikationen verwendet werden könnte die unsere API implementieren. Um nun von allen Arten von Applikationen Datenpakete zu erhalten ist es also Notwendig die selben Netzwerkschnittstellen zu verwenden wie es auch eben jene Applikationen tun.  
\\\\
Zwar müssen wir nur bei unserem Windows Treiber auf fremd Anwendungen achten aber auch bei unserem Proxy Server bringt uns dieses vorgehen einige Vorteile. Wir müssten Beispielsweiße NAT selbst implementieren. Da wir jedoch einen virtuellen Netzwerkadapter auch auf der Seite des Servers verwenden, können wir von bereits vorhandenen Implementierungen NATs gebrauch machen. Weiters eröffnet uns dies die Möglichkeit den Server einfach mit bereits vorhandener Netzwerksoftware zu erweitern, wie Beispielsweiße um eine Firewall.
\subsection{Treiber für virtuelle Netzwerkkarten im Linux Kernel}
Der Linux-Kernel enthält Standardmäßig einen sogenannten TUN/TAP Treiber. Dieser TUN/TAP Treiber erlaubt es "User Space" Programmen Zugriff auf rohe Netzwerkübertragungen zu nehmen. Dies ist der Fall da es einem ermöglicht wird virtuelle TUN/TAP Netzwerkadapter zu erstellen.
Virtuell bedeutet in diesem Fall das die erzeugten Netzwerkadapter nicht, wie gewöhnlich, physische Hardwaregeräte im Rechner sind, sondern nur virtuell im Kernel existieren. Sie besitzen somit keine physische Komponente. Abseits davon gibt es aber keinen unterschied zu einem physischen Adapter, es können wie gewohnt IP-Adressen, Subnetz etc konfiguriert werden.
\\\\
Dies bedeutet das Übertragungen die den virtuellen Adapter betreten nicht wie gewöhnlich als bits und bytes über ein Kabel, Funk oder ähnliches übertragen werden. Sondern stattdessen werden die Daten einer Anwendung als Bytestream zur Verfügung gestellt. Die Anwendung bekommt dabei einen "File descriptor" von diesem "File descriptor" kann die Anwendung sowohl lesen als auch schreiben. Es gilt dabei jedoch zu beachten das man nicht beliebige dinge in den Adapter schreiben kann, es muss sich entsprechend formatierte Pakete oder Frames handeln. Für das Betriebsystem selbst sieht es so aus als würde der Adapter wie gewöhnlich per Funk oder Kabel seine Daten lesen/schreiben.
\\\\
Es gibt bei TUN/TAP 2 Grundlegend unterschiedliche Modi. Der Unterschied besteht darin was wir am Ende von dem Adapter lesen beziehungsweise schreiben können. Die 2 Modi werden vom Namen schon angedeutet. Es gibt den TUN Modus und den TAP Modus. Mit welchem dieser beiden Modi der Netzwerkadapter am Ende arbeitet wird mittels eines Flags beim erstellen des Adapters festgelegt.
\\
\begin{description}
    \item[TAP - Netzwerk-Wasserhahn] TAP steht im Englischen für Wasserhahn und circa genau so Arbeitet auch ein TAP Gerät.
    Ein virtueller Netzwerkadapter der auf TAP Konfiguriert ist agiert auf OSI Schicht 2. 
    Beim lesen von dem virtuellen Adapter werden nur vollständige Ethernet-Frames gelesen und beim schreiben werden entsprechend auch nur vollständige Ethernet-Frames akzeptiert.
    \\
    \item[TUN - Netzwerk-Tunnel] TUN steht nicht wie TAP für einen Englischen Begriff sondern ist nur eine Abkürzung für Netzwerktunnel. 
    Ist ein virtueller Netzwerkadapter auf TUN konfiguriert Arbeitet er im gegensatz zu TAP nicht auf Schicht 2 sondern auf Schicht 3. Das bedeutet das er beim lesen nur vollständige IP-Pakete anbietet aber auch nicht mehr. Wärend er beim schreiben auch nur vollständige IP-Pakete akzeptiert. 
\end{description}
\

\subsubsection{Lebensdauer eines TUN/TAP Geräts}
Es TUN/TAP Gerät kann für 2 verschiedene Arten von Lebensdauer erstellt werden. Dabei gibt es eine kurzlebige variante und eine langlebige Variante. Die kurzlebige Variante heißt "transient" und die langlebige "persistent".
\\
\begin{description}
    \item[Transient] Ein Netzwerkadapter der "transient" ist wird von dem selben Prozess erstellt und auch gelöscht. Spätestens wenn sich der besitzende Prozess beendet wird auch der virtuelle Adapter zerstört.
    \item[Persistent] Ein virtueller Adapter der "persistent" ist ist wie der name schon sagt langlebig und existiert auch nach beenden des erstellendem Prozesses noch. Andere Prozesse können sich dann später mit dem Adapter verbinden und ihn verwenden. Damit der virtuelle Netzwerkadapter verschwindet muss er explizit gelöscht werden.
\end{description}

\subsubsection{Erstellen und verwalten eines TUN/TAP Geräts}
Um eine virtuelles TUN/TAP Gerät zu erstellen ist es notwendig die entsprechenden Rechte zu besitzen. Traditionelle UNIX Implementierungen unterscheiden grundsätzlich zwischen zwei Arten von Prozessen. Privilegierte Prozesse und unprivilegierte Prozesse. Die effektive UID eines privilegierten Prozesses ist immer 0 was bedeutet das er mit root Rechten gestartet wurde. Privilegierte Prozesse umgehen alle Berechtigungsüberprüfungen des Betriebsystems. 
\\\\
Seit Linux Kernel 2.2 wurden die Berechtigungen die sonst nur einem privilegiertem Prozess zur verfügung stehen weiter in einzelne Berechtigungen verfeinert. Die einzelnen Berechtigungen haben den Namen "Capabilities" und können auf einer per Thread Basis vergeben werden.
\\\\
Insgesamt gibt es 42 dieser Capabilities aber für das erstellen eines virtuellen Netzwerkadapters wird nur eine davon benötigt, nämlich \textbf{CAP\_NET\_ADMIN}. Diese Fähigkeit (Capability) erlaubt es einem Thread, neben dem erstellen eines virtuellen Adapters auch noch:
\\
\begin{enumerate}
    \item Netzwerkadapter zu konfigurieren
    \item Die Administration einer IP Firewall
    \item Die Routing Tabelle zu bearbeiten
    \item Sich an jede IP Adresse zu binden
    \item Den TOS (Type of Service) zu setzen 
    \item Treiber Statistiken zu bereinigen
    \item Einen Adapter in den "promiscuous mode" zu setzen
    \item Multicasting zu aktivieren
    \item Einige Socketoptionen zu setzen
\end{enumerate} 
% https://man7.org/linux/man-pages/man7/capabilities.7.html 
% https://backreference.org/2010/03/26/tuntap-interface-tutorial/
\ \\
Um nun tatsächlich ein TUN/TAP Gerät zu erstellen müssen wir zuerst auf das sogenante \textbf{clone device} zugreifen. Dieses befindet sich Standardmäßig unter \textbf{/dev/net/tun}.
\\\\
Dafür holen wir uns zuerst mit dem \textbf{open(\dq/dev/net/\dq, O\_RDWR);} Systemaufruf einen Dateideskriptor. Jetzt können wir mittels \textbf{ioctl(fd, TUNSETIFF, (void *) \&ifr);} Systemaufruf einen neuen Adapter erstellen.
\\\\
Der ioctl() Systemaufruf erlaubt es IO Geräte zu steuern. Dies geschieht indem unterliegende Geräte parameter manipuliert werden. Übergeben werden in unserem speziellen Fall zuerst der Dateideskriptor, dann die Konstante TUNSETIFF und zuguterletzt ein Zeiger zu einem ifreq struct das folgendermaßen aufgebaut ist:

\begin{program}[H]
    \begin{CppCode}
        struct ifreq {
            char ifr_name[IFNAMSIZ]; /* Interface name */
            union {
                struct sockaddr ifr_addr;
                struct sockaddr ifr_dstaddr;
                struct sockaddr ifr_broadaddr;
                struct sockaddr ifr_netmask;
                struct sockaddr ifr_hwaddr;
                short           ifr_flags;
                int             ifr_ifindex;
                int             ifr_metric;
                int             ifr_mtu;
                struct ifmap    ifr_map;
                char            ifr_slave[IFNAMSIZ];
                char            ifr_newname[IFNAMSIZ];
                char           *ifr_data;
            };
        };
    \end{CppCode}
\end{program}
\noindent
% https://man7.org/linux/man-pages/man7/netdevice.7.html
Die einzigen Felder die für uns beim erstellen relevant sind, sind ifr\_flags und ifr\_name. Bei ifr\_name Handelt es sich um den Namen des Netzwerkadapters welcher auch später bei ifconfig angezeigt wird. Wird kein Name angegeben wird ein generischer Name aller tun0 oder tap20 gewählt. Wärend ifr\_flags definiert ob es sich um ein TUN oder ein TAP Gerät handelt. Da es bei unserem Multi-Wan Proxy Server keinen Grund gibt Schicht 2 Protokolle wie ARP etc zu unterstützen, verwenden kein TAP Gerät sondern ein TUN Gerät welches nur IP-Pakete überträgt. 
\\\\ 
Wird unser ioctl() Systemaufruf erfolgreich abgeschlossen dann wurde der virtuelle Netzwerkadapter erstellt und der Dateideskriptor den wir zuvor erhalten haben kann nun verwendet werden um damit zu Kommunizieren. Hier vollständiger Beispielcode zum anlegen eines virtuellen Adapters:
\begin{program}[H]
    \begin{CppCode}
        #include <linux /if.h>
        #include <linux /if_tun.h>
        
        int tun_alloc(char *dev, int flags) {
          struct ifreq ifr;
          int fd;
          int error_code;
          char *clone_dev = "/dev/net/tun";
        
           /* Holen des Dateideskriptor vom clone device */
           if( (fd = open(clone_dev, O_RDWR)) < 0 ) {
             return fd;
           }
        
           /* Löscht alles an Inhalt aus dem struct */
           memset(&ifr, 0, sizeof(ifr));
        
           /* Das flag ist entweder IFF_TUN oder IFF_TAP
            * wobei auch noch IFF_NO_PI dazu geodert 
            * werden kann um Paket Informatioenn zu 
            * unterdrücken.
            */
           ifr.ifr_flags = flags;   
        
           /* Kopieren des Namen in das struct Fals angegeben */
           if (*dev) {
             strncpy(ifr.ifr_name, dev, IFNAMSIZ);
           }
        
           /* Hier wird dann versucht den Adapter zu erstellen */
           if( (error_code = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0 ) {
             close(fd);
             return error_code;
           }
        
          /* Nachdem das Gerät erstellt wurde wird nun
           * der Name aus dem struct kopiert. Dies ist 
           * Notwendig für die Situation in der kein Name
           * angegeben wurde. Desswegen muss auch immer 
           * ein Speicherbereich für den dev Zeiger 
           * übergeben werden.
           */
          strcpy(dev, ifr.ifr_name);
        
          /* Am Ende geben wir nur mehr den Dateideskriptor zurück 
           * den wir von nun an für alle weitere Kommunikation
           * mit dem Adapter verwenden.
           */
          return fd;
        }
    \end{CppCode}
\end{program}
\noindent
Der Adapter ist jetzt aber noch nicht persistent sonder erstmal nur transient. Um dies zu ändern erfordert es einige weitere ioctl() Aufrufe. Wir könnten den Adapter in diesen zustand aber schon ohne Probleme verwenden.
\\\\
Um das Netzwerkinterface jetzt auch noch persistent zu machen werden im normalfall zwei ioctl() Systemaufrufe gemacht. Mit dem ersten Aufruf machen wir des Netzwerkgerät tatsächlich schon persistent. Jedoch reicht das oft noch nicht. Der Code zum erstellen und zum einhängen in einen bereits vorhandenen Netzwerkadapter ist identisch, das bedeutet aber auch das die Berechtigungen identisch sein müssen. Wir wollen den Multi-Wan Bonding Proxy Server aber nicht immer mit root Berechtigungen laufen lassen da dies ein mögliches Sicherheitsrisiko darstellt. Die änderung des Besitzers und der Persistenz muss aber noch mit root Rechten erfolgen.
\\\\
Hier kommt uns der zweite ioctl() Aufruf zur Hilfe, dieser erlaubt es uns den Besitzer des virtuellen Netzwerkadapters zu einem nicht root Nutzer zu ändern, was es diesem ermöglicht zugriff zu nehmen. Zum löschen des Netzwerkadapters reicht es aus den Adapter wieder transient zu machen und den Prozess zu beenden. Hier Beispielcode zur Persistentmachung eines virtuellen Netzwerkadapters:
\begin{program}[H]
    \begin{CppCode}
        if(ioctl(tap_fd, TUNSETPERSIST, 1) < 0){
            perror("enabeling TUNSETPERSIST");
            exit(1);
        }
        
        int owner{1002}; // UID des neuen Besitzers
        if(ioctl(tap_fd, TUNSETOWNER, owner) < 0){
            perror("TUNSETOWNER");
            exit(1);
        }

        // Loeschen eines virtuellen Netzwerkadapters
        if(ioctl(tap_fd, TUNSETPERSIST, 0) < 0){
            perror("disabling TUNSETPERSIST");
        }
        exit(0);
    \end{CppCode}
\end{program}
\noindent
Ein Prozess der nun mit der effektiven UID des Adapterbesitzers läuft kann nun mit dem selben Code mit dem normal ein virtueller Netzwerkadapter erstellt wird diesen einhängen. Dabei ist zu beachten das dazu versucht werden muss einen Netzwerkadapter mit genau demselben Namen zu erstellen, wie der für den wir Rechte bekommen haben hat. Generell sollte man versuchen einen weiteren Adapter mit dem selben Namen zu erstellen wir der bereits existierende einfach nur eingehangen sofern man ausreichende Berechtigungen hat.

\subsubsection{Lesen und schreiben von einem TUN/TAP Gerät}
Zum lesen und schreiben verwenden wir einfach den read() und write() Systemaufruf. Diese werden für das Lesen und schreiben von praktisch alles Geräten und Datein verwendet. 
\\
\begin{description}
    \item[read() - Systemaufruf] Bei read() werden drei Parameter übergeben. Zuerst der Dateideskriptor von dem wir lesen möchten, dann ein Zeiger auf einen char Array Buffer und zuguterletzt die Anzahl der zu lesenden Bytes. read() blockiert bis die gewünschte Anzahl an Bytes in den Buffer gelesen wurde oder wir an das Dateiende kommen beziehungsweise bis es zu einem Fehler kommt. Ist read() erfolgreich wird die Anzahl an gelesenen Bytes zurückgegeben, im Fehlerfall wird ein Fehlercode kleiner 0 zurückgegeben.
    \\% https://man7.org/linux/man-pages/man2/read.2.html
    \item[write() - Systemaufruf] Es werden dabei wie auch bei read() der Dateideskriptor, char array Zeiger und größe übergeben. write() blockiert solange bis die Anzahl an bytes per größe übergeben aus dem char array gelesen und in die Datei geschrieben wurden oder ein größen limit der Datei erreicht wurde. Sollte es zu einem Fehler kommen wird auch hier eine Zahl kleiner 0 zurückgegeben, sonst wird die Anzahl der geschriebenen Bytes zurückgegeben.
    % https://man7.org/linux/man-pages/man2/write.2.html
\end{description}
\ \\
Da wir vermeiden möchten Datenpakete zu halbieren oder zumindest nicht vollständig zu lesen und zu schreiben. Müssen wir rücksicht auf die Maximum transmission unit (MTU) des virtuellen Netzwerkadapters nehmen. Die MTU beschreibt die größe der größten möglichen Protokoll Daten Einheit und steht in Verbindung zu der maximalen Frame größe die auf OSI Schicht 2 übertragen werden kann. Bei Ethernet beträgt die MTU 1500 Bytes vorrausgesetzt Jumboframes sind nicht aktiviert was bei unserem virtuellen Adapter nicht der Fall ist.
\\\\
Wir schreiben und lesen von unserem virtuellen Netzwerkadapter also immer maximal 1500 Bytes so können wir sicher gehen das wir immer vollständige Datenpakete entgegennehmen und schreiben.
\\\\
Physisch könnte man sich das nachfolgende Beispiel so vorstellen als hätte man in einem Rechner zwei Ethernet Netzwerkadapter und würde beide mit einem Patchkabel miteinander verbinden. Es ist zwar nicht besonders sinnvoll dies zu tun aber wir können so gut zeigen wie das schreiben und lesen von einem virtuellen Adapter funktioniert. Im Beispiel wird auch ein select() Systemaufruf verwendet um zu überprüfen ob in einem der beiden virtuellen Netzwerkadaptern gerade Datenpakete verfügbar sind und nur dann wird versucht zu lesen. 
\begin{program}[H]
    \begin{CppCode}
        char tun_name1[IFNAMSIZ];
        char tun_name2[IFNAMSIZ];
        char* buffer = new char[1500]; /* MTU größe */
        int tun_fd1, tun_fd2;
  
        /* Erstellen oder einhängen des TUN Adapters */
        strcpy(tun_name1, "tun1");
        tun_fd1 = tun_alloc(tun_name1, IFF_TUN | IFF_NO_PI);

        /* Erstellen oder einhängen des zweiten TUN Adapters */
        strcpy(tun_name2, "tun2");
        tun_fd2 = tun_alloc(tun_name2, IFF_TUN | IFF_NO_PI);
      
        if(tun_fd1 < 0 || tun_fd2 < 0){
          perror("Fehler beim erstellen/einhängen.");
          exit(1);
        }
      
        /* Daten lesen und schreiben. */
        uint16_t nread, nwrite;
        int maxfd = (tun_fd1 > tun_fd12) ? tun_fd1 : tun_fd2;
        while(1) {
            int ret;
            fd_set rd_set;
        
            FD_ZERO(&rd_set);
            FD_SET(tun_fd1, &rd_set); FD_SET(tun_fd2, &rd_set);

            /* Warten auf änderungen bei einem der beiden Dateideskriptoren */
            ret = select(maxfd + 1, &rd_set, nullptr, nullptr, nullptr);
        
            if (ret < 0 && errno == EINTR) {
              continue;
            }
        
            if (ret < 0) {
              perror("select()");
              exit(1);
            }

            // Lesen von tun1 und schreiben in tun2 wenn Inhalt in tun1
            if(FD_ISSET(tun_fd1, &rd_set)) {
                nread = read(tun_fd1, buffer, sizeof(buffer));
                if(nread < 0) {
                    perror("Lesen vom Interface");
                    close(tun_fd1); close(tun_fd2);
                    exit(1);
                }
                printf("Gelesen %d bytes von Gerät %s\n", nread, tun_name1);

                nwrite = write(tun_fd2, buffer, nread);
                if(nwrite < 0) {
                    perror("Schreiben zum Interface");
                    close(tun_fd1); close(tun_fd2);
                    exit(1);
                }
                printf("Geschrieben %d bytes in Gerät %s\n", nwrite, tun_name2);
            }
    \end{CppCode}
\end{program}
\noindent
\begin{program}[H]
    \begin{CppCode}
        // Lesen von tun2 und schreiben in tun1 wenn Inhalt in tun2
        if(FD_ISSET(tun_fd2, &rd_set)) {
            nread = read(tun_fd2, buffer, sizeof(buffer));
            if(nread < 0) {
                perror("Lesen vom Interface");
                close(tun_fd1); close(tun_fd2);
                exit(1);
            }
            printf("Gelesen %d bytes von Gerät %s\n", nread, tun_name2);

            nwrite = write(tun_fd1, buffer, nread);
            if(nwrite < 0) {
                perror("Schreiben zum Interface");
                close(tun_fd1); close(tun_fd2);
                exit(1);
            }
            printf("Geschrieben %d bytes in Gerät %s\n", nwrite, tun_name1);
        }
    }
    \end{CppCode}
\end{program}
\noindent
\subsection{Kommunikation mit unserem Multi-Wan Bonding Windows-Treiber}
Zur Kommunikation zwischen dem Proxy Server und dem Windows Treiber verwenden wir die normale Linux Socket API. Wir setzen hier auf UDP Datagrams. Wie wir schon im vorherigen Abschnitt über den TUN/TAP Treiber lernen konnten sind die größten IP-Pakete mit denen wir rechnen müssen 1500 Bytes groß. Bei der Kommunikation zwischen Server und Windows Treiber machen wir nun nichts anderes als ein UDP Datagram zu verschicken welches als Nutzdaten das IP-Paket enthält welches wir von dem TUN Interface bekommen haben. Genauso läuft es auch in die andere Richtung. 
\\\\
Empfangen wir ein UDP Datagram bei unserem Server nehmen wir einfach die Nutzdaten und übergeben sie mit einem write() Systemaufruf an das TUN Interface. Dabei ist uns egal von wo dieses UDP Datagram ursprünglich herkommt. Es werden einfach alle eingehenden Datagrams auf Port 5555 genommen und deren Nutzdaten an den virtuellen Netzwerkadapter übergeben ohne weitere verarbeitungsschritte dazwischen. 
\\\\
Der Port und die IP-Adresse des Absenders des Datagrams wird in einem Set zwischengespeichert. Lesen wir nun mit einem read() Systemaufruf ein IP-Paket aus dem TUN Interface wird einfach zufällig ein Endpunkt(IP-Adresse und Port) aus dem Set ausgewählt und das IP-Paket mittels sendto() Systemaufruf als UDP Datagram an den Windows Treiber gesendet. Hier gibt es vermutlich noch einigen Freiraum an Verbesserung. So könnten wir Beispielsweiße nicht allen Verbindungen zum Server die selbe Warscheinlichkeit für eine Antwort geben sondern anhand von Bandbreite oder Ping Zeit unterschiedliche Warscheinlichkeiten vergeben. Auch könnte man vielleicht zusammengehörige Pakete beisammenhalten um TCP Reinfolgenfehler zu vermeiden.
\\\\
Um unter C/C++ auf einem UDP Port zu lauschen müssen wir zuerst wieder einen Dateideskriptor erstellen. Dies tun wir im Fall von Sockets mittels des socket() Systemaufrufs. Dieser erstellt uns einen Endpunkt zu Kommunikation und gibt uns einen Dateideskriptor der auf diesen Zeigt. socket() erwartet drei Parameter:
\\\\
Prototyp: int socket(int domain, int type, int protocol);
\begin{enumerate}
    \item \textbf{int domain}: Gibt an um welche Kommunikationsdomaine es sich Handelt. Dies kann Beispielsweiße IPv4, IPv6 aber auch genau so gut Bluetooth sein. In unserem Fall wird es sich um IPv4 Handeln.
    \item \textbf{int type}: Beschreibt die Semantik der Kommunikation. Jenachdem was wir hier angeben können wir mittels Streams, Datagrams, Paketen oder SEQPaketen kommunizieren.
    \item \textbf{int protocol}: Hier geben wir das Kommunikationsprotokoll an. Entweder TCP, UDP oder weitere andere je nachdem welche domain und type wir verwenden. In unserem Fall verwenden wir UDP.
    \item \textbf{Rückgabe}: Zurückgegeben wird uns der Dateideskriptor des sockets.
\end{enumerate} 
\ \\%https://man7.org/linux/man-pages/man2/socket.2.html
Nachdem wir unseren Dateideskriptor erhalten haben hat der socket aber noch keine IP-Adresse oder ähnliches. Mittels bind() Systemaufruf können wir nun dem Socket eine IP-Adresse zuweißen. Diese Operation wird traditionel als Namensgebung des Sockets bezeichnet. bind() erwartet 3 Parameter.
\\\\
Prototyp: int bind(int sockfd, const struct sockaddr *addr, socklen\_t addrlen);
\begin{enumerate}
    \item \textbf{int sockfd}: Der Dateideskriptor des Sockets.
    \item \textbf{const struct sockaddr *addr}: Hier wird die eigentliche Adresse übergebn und um welche Adressfamilie es sich Handelt. 
    \item \textbf{socklen\_t addrlen}: Hier übergeben wir die Länge der Adresse diese hängt unter anderem von der Adressfamilie ab.
    \item \textbf{Rückgabe}: 0 wenn erfolgreich gesetzt. -1 im Fehlerfall.
\end{enumerate} 
\ \\%https://man7.org/linux/man-pages/man2/bind.2.html
Unser socket ist damit Fertig alles was wir jetzt noch machen müssen ist mittels recvfrom() Daten aus dem Socket zu lesen. Im Falle unserer Serverimplementierung wird davor aber noch mit einem select() Systemaufruf überprüft ob es Daten zu lesen gibt. Für gewöhnlich wird ein recv() Systemaufruf verwendet dies ist hier aber ausnahmsweiße nicht der Fall da wir keine Verbindung zu einem fixen Enterfnten Endpunkt haben sondern von vielen verschiedenen Endpunkten Daten empfangen können.
\\\\
Prototyp: ssize\_t recvfrom(int sockfd, void *buf, size\_t len, int flags, struct sockaddr *src\_addr, socklen\_t *addrlen);
\begin{enumerate}
    \item \textbf{int sockfd}: Der Dateideskriptor des Sockets.
    \item \textbf{void *buf}: Ein Zeiger auf das char array welches die empfangenen Daten nachher beinhalten soll. 
    \item \textbf{size\_t len}: Gibt die größe des Buffers an in den wir lesen möchten.
    \item \textbf{int flags}: Damit lassen sich eigenschaften von recvfrom() ändern. Beispielsweiße ob es ein blockierender Aufruf ist oder nicht.
    \item \textbf{struct sockaddr *src\_addr}: Hier übergeben wir einen Zeiger zu einem socketaddr struct in welches recvfrom() beim Empfangen die Absender Adresse schreibt.
    \item \textbf{ssocklen\_t *addrlen}: Ein Zeiger auf die länge der Adresse. Der Inhalt wird entsprechend der Absenderadresse geändert.
    \item \textbf{Rückgabe}: 0 wenn Verbindung ordnungsgemäß getrennt. Anzahl der Bytes wenn welche empfangen wurden. -1 im Fehlerfall.
\end{enumerate} 
\ \\%https://linux.die.net/man/2/recvfrom
